# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o3GhLNRVXa8yKr6cDw6zHHbbq_vN-aa9
"""

#Question 2

try:   
    entrée = int(input("Entrez une nombre ")) #variable qui permet a l'utilisateur de rentrer un nombre 

    #nous creons une boucle qui lorque la variable entrée est negative, complexe, grand nombre nous affiche l'erreur sinon execute le code de la question "FACTORIELLE"
    if entrée < 0 or entrée >=1000 or type(entrée) != float: 
        print("le nombre entrée est incorrect")
    else:
        if entrée == 0:
            x=1
        function = (entrée*3) - (1.5(entrée**2))- (6*entrée) + 5
        print(function)

except ValueError:
    print("La valeur entrée est incorrect")

#Question 1.c
nterms = int(input("Entrez un nombre: "))
 
y1 = 0
y2 = 1
 
print("\n la suite fibonacci est :")
print(y1, ",", y2, end=", ")
 
for i in range(2, nterms):
  suivant = y1 + y2
  print(suivant, end=", ")
 
  y1 = y2
  y2 = suivant  #quand on valide une cage va souvrir ensuite on y mettre le nombre+entrée

# question 3
import numpy as np
import scipy.stats as si
import sympy as sy
import sympy.stats as systats

def euro_vanilla_call(S, K, T, r, sigma):    
    
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = (np.log(S / K) + (r - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    
    call = (S * si.norm.cdf(d1, 0.0, 1.0) - K * np.exp(-r * T) * si.norm.cdf(d2, 0.0, 1.0))
    
    return call

def euro_vanilla_put(S, K, T, r, sigma):    
    
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = (np.log(S / K) + (r - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    
    put = (-S * si.norm.cdf(-d1, 0.0, 1.0) + K * np.exp(-r * T) * si.norm.cdf(-d2, 0.0, 1.0))
    
    return put
 


def euro_vanilla_call_dividendes(S, K, T, r, q, sigma):    
    
    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = (np.log(S / K) + (r - q - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    
    call = (S * np.exp(-q * T) * si.norm.cdf(d1, 0.0, 1.0) - K * np.exp(-r * T) * si.norm.cdf(d2, 0.0, 1.0))
    
    return call
	
def euro_vanilla_put_dividendes(S, K, T, r, q, sigma):    
    
    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = (np.log(S / K) + (r - q - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    
    put = (-S * np.exp(-q * T) * si.norm.cdf(-d1, 0.0, 1.0) + K * np.exp(-r * T) * si.norm.cdf(-d2, 0.0, 1.0))
    
    return put

#Question 1.a
def fonction (x):
    function = (x**3) - 1.5*(x**2)- (6*x) + 5
    return function
fonction(5)

#b/Question 1.b
def facto (n): 
    fact = 1
    for i in range(1, n+1):
      fact = fact * i
    print (n,'! = ',fact)

facto(5)